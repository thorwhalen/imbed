

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>imbed.util &mdash; imbed 0.0.21 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=a11416ff"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            imbed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed.html">imbed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/base.html">imbed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components.html">imbed.components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components/clusterization.html">imbed.components.clusterization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components/components_util.html">imbed.components.components_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components/planarization.html">imbed.components.planarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components/segmentation.html">imbed.components.segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/components/vectorization.html">imbed.components.vectorization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/data_prep.html">imbed.data_prep</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/examples.html">imbed.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/examples/batch_embeddings_examples.html">imbed.examples.batch_embeddings_examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/examples/boxes.html">imbed.examples.boxes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/examples/boxes/planarize.html">imbed.examples.boxes.planarize</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/examples/imbed_box_01.html">imbed.examples.imbed_box_01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/imbed_project.html">imbed.imbed_project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/imbed_types.html">imbed.imbed_types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/mdat.html">imbed.mdat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/oa_batch_embeddings.html">imbed.oa_batch_embeddings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/segmentation_util.html">imbed.segmentation_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/stores_util.html">imbed.stores_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/tests.html">imbed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/tests/test_imbed_project.html">imbed.tests.test_imbed_project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/tests/test_segmentation.html">imbed.tests.test_segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/tests/utils_for_tests.html">imbed.tests.utils_for_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/tools.html">imbed.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/util.html">imbed.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/imbed/vector_db.html">imbed.vector_db</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">imbed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">imbed.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for imbed.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Utils for imbed package.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">importlib.resources</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">KT</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Coroutine</span><span class="p">,</span>
    <span class="n">ParamSpec</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">config2py</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_app_data_folder</span><span class="p">,</span> <span class="n">process_path</span><span class="p">,</span> <span class="n">simple_config_getter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lkj</span><span class="w"> </span><span class="kn">import</span> <span class="n">clog</span> <span class="k">as</span> <span class="n">clog</span><span class="p">,</span> <span class="n">print_with_timestamp</span><span class="p">,</span> <span class="n">log_calls</span> <span class="k">as</span> <span class="n">_log_calls</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">graze</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">graze</span> <span class="k">as</span> <span class="n">_graze</span><span class="p">,</span>
    <span class="n">Graze</span> <span class="k">as</span> <span class="n">_Graze</span><span class="p">,</span>
    <span class="n">GrazeReturningFilepaths</span> <span class="k">as</span> <span class="n">_GrazeReturningFilepaths</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">pkg_files</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">resources</span><span class="o">.</span><span class="n">files</span><span class="p">(</span><span class="s2">&quot;imbed&quot;</span><span class="p">)</span>
<span class="c1"># test_data_files = pkg_files / &quot;tests&quot; / &quot;data&quot;</span>


<span class="n">mk_factory</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">partial</span><span class="p">,</span> <span class="n">partial</span>
<span class="p">)</span>  <span class="c1"># see https://medium.com/@thorwhalen1/partial-partial-partial-f90396901362</span>

<span class="n">fullpath_factory</span> <span class="o">=</span> <span class="n">mk_factory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">)</span>

<span class="n">MappingFactory</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">]</span>

<span class="n">package_name</span> <span class="o">=</span> <span class="s2">&quot;imbed&quot;</span>
<span class="n">app_data_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="s2">&quot;IMBED_APP_DATA_FOLDER&quot;</span><span class="p">,</span>
    <span class="n">get_app_data_folder</span><span class="p">(</span><span class="n">package_name</span><span class="p">,</span> <span class="n">ensure_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">DFLT_DATA_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">app_data_folder</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">DFLT_PROJECTS_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">DFLT_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;projects&quot;</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">GRAZE_DATA_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">DFLT_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;graze&quot;</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">DFLT_SAVES_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">DFLT_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;saves&quot;</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">DFLT_CONFIG_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">DFLT_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">DFLT_BATCHES_DIR</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">DFLT_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;batches&quot;</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="n">saves_join</span> <span class="o">=</span> <span class="n">fullpath_factory</span><span class="p">(</span><span class="n">DFLT_SAVES_DIR</span><span class="p">)</span>
<span class="n">get_config</span> <span class="o">=</span> <span class="n">simple_config_getter</span><span class="p">(</span><span class="n">DFLT_CONFIG_DIR</span><span class="p">)</span>

<span class="n">graze_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">rootdir</span><span class="o">=</span><span class="n">GRAZE_DATA_DIR</span><span class="p">,</span>
    <span class="n">key_ingress</span><span class="o">=</span><span class="n">_graze</span><span class="o">.</span><span class="n">key_ingress_print_downloading_message_with_size</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">graze</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_graze</span><span class="p">,</span> <span class="o">**</span><span class="n">graze_kwargs</span><span class="p">)</span>
<span class="n">grazed_path</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">graze</span><span class="p">,</span> <span class="n">return_filepaths</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Graze</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_Graze</span><span class="p">,</span> <span class="o">**</span><span class="n">graze_kwargs</span><span class="p">)</span>
<span class="n">GrazeReturningFilepaths</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_GrazeReturningFilepaths</span><span class="p">,</span> <span class="o">**</span><span class="n">graze_kwargs</span><span class="p">)</span>


<span class="n">non_alphanumeric_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W+&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dict_slice</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lower_alphanumeric</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">non_alphanumeric_re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<div class="viewcode-block" id="hash_text">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.hash_text">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hash_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a hash of the text, ignoring punctuation and capitalization.</span>

<span class="sd">    &gt;&gt;&gt; hash_text(&#39;Hello, world!&#39;)</span>
<span class="sd">    &#39;5eb63bbbe01eeed093cb22bb8f5acdc3&#39;</span>
<span class="sd">    &gt;&gt;&gt; hash_text(&#39;hello world&#39;)</span>
<span class="sd">    &#39;5eb63bbbe01eeed093cb22bb8f5acdc3&#39;</span>
<span class="sd">    &gt;&gt;&gt; hash_text(&#39;Hello, world!&#39;) == hash_text(&#39;hello world&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hashlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">md5</span>

    <span class="n">normalized_text</span> <span class="o">=</span> <span class="n">lower_alphanumeric</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">md5</span><span class="p">(</span><span class="n">normalized_text</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">lenient_bytes_decoder</span><span class="p">(</span><span class="n">bytes_</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bytes_</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bytes_</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;replace&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bytes_</span>


<span class="c1"># decorator that logs calls</span>
<span class="n">log_calls</span> <span class="o">=</span> <span class="n">_log_calls</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">print_with_timestamp</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># decorator that logs calls of methods if the instance verbose flat is set</span>
<span class="n">log_method_calls</span> <span class="o">=</span> <span class="n">_log_calls</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">print_with_timestamp</span><span class="p">,</span>
    <span class="n">log_condition</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">_log_calls</span><span class="o">.</span><span class="n">instance_flag_is_set</span><span class="p">,</span> <span class="n">flag_attr</span><span class="o">=</span><span class="s2">&quot;verbose&quot;</span><span class="p">),</span>
<span class="p">)</span>


<div class="viewcode-block" id="async_sync_wrapper">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.async_sync_wrapper">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">async_sync_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decorator that adds an async and a sync version of a function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sync_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">func</span><span class="o">.</span><span class="n">async_version</span> <span class="o">=</span> <span class="n">async_wrapper</span>
    <span class="n">func</span><span class="o">.</span><span class="n">sync_version</span> <span class="o">=</span> <span class="n">sync_wrapper</span>
    <span class="k">return</span> <span class="n">func</span></div>



<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="async_call">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.async_call">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_call</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Coroutine</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls a function, awaiting it if it&#39;s asynchronous, and running it in a thread if it&#39;s synchronous.</span>

<span class="sd">    Args:</span>
<span class="sd">        func: The function to call.</span>
<span class="sd">        *args: Positional arguments to pass to the function.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to the function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The result of the function call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># mdat utils</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_submodule_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.py&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">module_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span><span class="w"> </span><span class="nf">submodules_of</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">include_init</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">resources</span><span class="o">.</span><span class="n">files</span><span class="p">(</span><span class="n">pkg</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="n">is_submodule_path</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">include_init</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;__init__&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>


<span class="n">EmbeddingKey</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EmbeddingKey&quot;</span><span class="p">)</span>
<span class="n">Metadata</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">MetaFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">EmbeddingKey</span><span class="p">],</span> <span class="n">Metadata</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Embeddings</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">embeddings</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">EmbeddingKey</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MetaFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_query_hits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">embeddings</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span> <span class="o">=</span> <span class="n">meta</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_mapping</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">EmbeddingKey</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">meta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">embedding_col</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span> <span class="n">key_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">embedding_col</span><span class="p">],</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">embedding_col</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="n">key_col</span><span class="p">],</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_embedding</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the n closest embeddings to the query embedding.&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics.pairwise</span><span class="w"> </span><span class="kn">import</span> <span class="n">cosine_similarity</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_query_hits</span>
        <span class="n">similarities</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span>
            <span class="n">query_embedding</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">embeddings</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span> <span class="n">similarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)[:</span><span class="n">n</span><span class="p">]</span>


<div class="viewcode-block" id="cosine_similarity">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.cosine_similarity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cosine_similarity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the cosine similarity between two vectors or arrays of vectors.</span>

<span class="sd">    If both inputs are 1D vectors, returns a float.</span>
<span class="sd">    If one or both inputs are 2D arrays, returns either a 1D array (row-wise)</span>
<span class="sd">    or a 2D array (cartesian product of rows) depending on the cartesian_product flag.</span>

<span class="sd">    Behavior for row-wise (cartesian_product=False):</span>
<span class="sd">      - If both arrays have the same number of rows, compares row i of u to row i of v.</span>
<span class="sd">      - If one array has only 1 row, it is broadcast against each row of the other array.</span>
<span class="sd">        (Returns a 1D array of length k, where k is the number of rows in the multi-row array.)</span>

<span class="sd">    Args:</span>
<span class="sd">        u (array-like): A single vector (1D) or a 2D array (k1 x n),</span>
<span class="sd">                        where each row is a separate vector.</span>
<span class="sd">        v (array-like): A single vector (1D) or a 2D array (k2 x n).</span>
<span class="sd">        cartesian_product (bool, optional):</span>
<span class="sd">            - If False (default), the function compares rows in a one-to-one fashion (u[i] vs. v[i]),</span>
<span class="sd">              **except** if one array has exactly 1 row and the other has multiple rows, in which case</span>
<span class="sd">              that single row is broadcast to all rows of the other array.</span>
<span class="sd">            - If True, computes the similarity for every combination of rows</span>
<span class="sd">              (results in a 2D array of shape (k1, k2)).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float or np.ndarray:</span>
<span class="sd">            - A float if both u and v are 1D vectors.</span>
<span class="sd">            - A 1D numpy array if either u or v is 2D and cartesian_product=False.</span>
<span class="sd">            - A 2D numpy array if cartesian_product=True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:</span>
<span class="sd">            - If the number of columns in u and v do not match.</span>
<span class="sd">            - If cartesian_product=False, both arrays have multiple rows but differ in row count.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    `See here for an explanation of the cases &lt;https://github.com/thorwhalen/imbed/discussions/9#discussioncomment-11968528&gt;`_.</span>

<span class="sd">    `See here for a performance comparison of numpy (this function) versus scipy &lt;https://github.com/thorwhalen/imbed/discussions/9#discussioncomment-11971474&gt;`_.</span>

<span class="sd">    Case 1: Both are single 1D vectors</span>

<span class="sd">    &gt;&gt;&gt; u1d = [2, 0]</span>
<span class="sd">    &gt;&gt;&gt; v1d = [2, 0]</span>
<span class="sd">    &gt;&gt;&gt; float(cosine_similarity(u1d, v1d))</span>
<span class="sd">    1.0</span>

<span class="sd">    Case 2: Single 1D vector vs. a 2D array (row-wise broadcast)</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; M1 = np.array([</span>
<span class="sd">    ...     [2, 0],</span>
<span class="sd">    ...     [0, 2],</span>
<span class="sd">    ...     [2, 2]</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; cosine_similarity(u1d, M1)  # doctest: +ELLIPSIS</span>
<span class="sd">    array([1.        , 0.        , 0.70710678...])</span>

<span class="sd">    Case 3: Two 2D arrays of different row lengths, cartesian_product=False (raises ValueError)</span>

<span class="sd">    &gt;&gt;&gt; M2_different = np.array([</span>
<span class="sd">    ...     [0, 2],</span>
<span class="sd">    ...     [2, 2]</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; # Expect a ValueError because M1 has 3 rows and M2_different has 2 rows</span>
<span class="sd">    &gt;&gt;&gt; cosine_similarity(M1, M2_different, cartesian_product=False)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: For row-wise comparison, u and v must have the same number of rows...</span>

<span class="sd">    Case 4: Two 2D arrays of the same number of rows, cartesian_product=False</span>

<span class="sd">    &gt;&gt;&gt; M2 = np.array([</span>
<span class="sd">    ...     [0, 2],</span>
<span class="sd">    ...     [2, 0],</span>
<span class="sd">    ...     [2, 2]</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; cosine_similarity(M1, M2, cartesian_product=False)</span>
<span class="sd">    array([0., 0., 1.])</span>

<span class="sd">    Case 5: Two 2D arrays of the same size, `cartesian_product=True`</span>
<span class="sd">    (computes every combination of rows =&gt; 3 x 3)</span>

<span class="sd">    &gt;&gt;&gt; res5 = cosine_similarity(M1, M2, cartesian_product=True)</span>
<span class="sd">    &gt;&gt;&gt; np.round(res5, 3)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[0.   , 1.   , 0.707],</span>
<span class="sd">           [1.   , 0.   , 0.707],</span>
<span class="sd">           [0.707, 0.707, 1.   ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert inputs to numpy arrays</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># --------------- CASE 1: Both are single 1D vectors ---------------</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vectors u and v must have the same dimension.&quot;</span><span class="p">)</span>
        <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">norm_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dot_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_u</span> <span class="o">*</span> <span class="n">norm_v</span><span class="p">)</span>

    <span class="c1"># --------------- CASE 2: At least one is 2D; ensure both are 2D ---------------</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># shape (n,) -&gt; (1, n)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># shape (n,) -&gt; (1, n)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Check that columns (vector dimension) match</span>
    <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inconsistent dimensions: u has </span><span class="si">{</span><span class="n">n1</span><span class="si">}</span><span class="s2"> columns, v has </span><span class="si">{</span><span class="n">n2</span><span class="si">}</span><span class="s2"> columns.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># --------------- CARTESIAN PRODUCT ---------------</span>
    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="c1"># (k1 x k2) dot products</span>
        <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">u</span> <span class="o">@</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># shape (k1, k2)</span>
        <span class="n">norm_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k1,)</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k2,)</span>
        <span class="c1"># Outer product of norms =&gt; shape (k1, k2)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">norm_u</span><span class="p">,</span> <span class="n">norm_v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dot_uv</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="c1"># --------------- ROW-WISE (NOT CARTESIAN) ---------------</span>
    <span class="c1"># 1) If one array has a single row (k=1), broadcast it against each row of the other</span>
    <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Broadcast u&#39;s single row against each row in v</span>
        <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k2,)</span>
        <span class="n">norm_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># scalar</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k2,)</span>
        <span class="k">return</span> <span class="n">dot_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_u</span> <span class="o">*</span> <span class="n">norm_v</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">k2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Broadcast v&#39;s single row against each row in u</span>
        <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k1,)</span>
        <span class="n">norm_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k1,)</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># scalar</span>
        <span class="k">return</span> <span class="n">dot_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_u</span> <span class="o">*</span> <span class="n">norm_v</span><span class="p">)</span>

    <span class="c1"># 2) Otherwise, require the same number of rows</span>
    <span class="k">if</span> <span class="n">k1</span> <span class="o">!=</span> <span class="n">k2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;For row-wise comparison, u and v must have the same number of rows. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(u has </span><span class="si">{</span><span class="n">k1</span><span class="si">}</span><span class="s2">, v has </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
    <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (k1,)</span>
    <span class="n">norm_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">norm_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dot_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_u</span> <span class="o">*</span> <span class="n">norm_v</span><span class="p">)</span></div>



<div class="viewcode-block" id="transpose_iterable">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.transpose_iterable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transpose_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is useful to do things like:</span>

<span class="sd">    &gt;&gt;&gt; xy_values = [(1, 2), (3, 4), (5, 6)]</span>
<span class="sd">    &gt;&gt;&gt; x_values, y_values = transpose_iterable(xy_values)</span>
<span class="sd">    &gt;&gt;&gt; x_values</span>
<span class="sd">    (1, 3, 5)</span>
<span class="sd">    &gt;&gt;&gt; y_values</span>
<span class="sd">    (2, 4, 6)</span>

<span class="sd">    Note that transpose_iterable is an [involution](https://en.wikipedia.org/wiki/Involution_(mathematics))</span>
<span class="sd">    (if we disregard types).</span>

<span class="sd">    &gt;&gt;&gt; list((x_values, y_values))</span>
<span class="sd">    [(1, 3, 5), (2, 4, 6)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterable</span><span class="p">)</span></div>



<span class="c1"># umap utils ---------------------------------------------------------------------------</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">KT</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">imbed.imbed_types</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">EmbeddingMapping</span><span class="p">,</span>
    <span class="n">EmbeddingType</span><span class="p">,</span>
    <span class="n">PlanarEmbedding</span><span class="p">,</span>
    <span class="n">PlanarVectorMapping</span><span class="p">,</span>
    <span class="n">SegmentsSpec</span><span class="p">,</span>
    <span class="n">SegmentMapping</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="ensure_segments_mapping">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.ensure_segments_mapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_segments_mapping</span><span class="p">(</span><span class="n">segments</span><span class="p">:</span> <span class="n">SegmentsSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SegmentMapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that the segments are in the correct format.</span>

<span class="sd">    :param segments: a SegmentMapping or a Sequence of Segments</span>
<span class="sd">    :return: a SegmentMapping</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">segments</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="n">segments</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">segment</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected a Mapping or Sequence of Segments, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">segments</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="ensure_embedding_dict">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.ensure_embedding_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_embedding_dict</span><span class="p">(</span><span class="n">embeddings</span><span class="p">:</span> <span class="n">EmbeddingMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EmbeddingMapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that the embeddings are in the correct format.</span>

<span class="sd">    :param embeddings: a dict of embeddings</span>
<span class="sd">    :return: a dict of embeddings</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Expected a Mapping, but got a DataFrame. &quot;</span>
            <span class="s2">&quot;Convert this DataFrame to a Mapping of embeddings first.&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">embeddings</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Make sure kd_embeddings is a Mapping with embedding values</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">embeddings</span><span class="p">,</span> <span class="n">Mapping</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected a Mapping, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">embeddings</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">first_embedding</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">embeddings</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_embedding</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">first_embedding</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected kd_embeddings to be a Mapping with unidimensional values, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">first_embedding</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions: </span><span class="si">{</span><span class="n">first_embedding</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_embedding</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected kd_embeddings to be a Mapping with Sequence values, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">first_embedding</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">first_embedding</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">embeddings</span></div>



<span class="n">PlanarEmbeddingKind</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;umap&quot;</span><span class="p">,</span> <span class="s2">&quot;ncvis&quot;</span><span class="p">,</span> <span class="s2">&quot;tsne&quot;</span><span class="p">,</span> <span class="s2">&quot;pca&quot;</span><span class="p">]</span>
<span class="n">PlanarEmbeddingFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">EmbeddingType</span><span class="p">]],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">PlanarEmbedding</span><span class="p">]]</span>
<span class="n">DFLT_PLANAR_EMBEDDING_KIND</span> <span class="o">=</span> <span class="s2">&quot;umap&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">planar_embeddings_func</span><span class="p">(</span>
    <span class="n">embeddings_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">PlanarEmbeddingKind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">DFLT_PLANAR_EMBEDDING_KIND</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">distance_metric</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlanarEmbeddingFunc</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">embeddings_func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">embeddings_func</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embeddings_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">embeddings_func</span> <span class="o">==</span> <span class="s2">&quot;umap&quot;</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">umap</span>  <span class="c1"># pip install umap-learn</span>

            <span class="k">return</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span>
        <span class="k">elif</span> <span class="n">embeddings_func</span> <span class="o">==</span> <span class="s2">&quot;tsne&quot;</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.manifold</span><span class="w"> </span><span class="kn">import</span> <span class="n">TSNE</span>

            <span class="k">return</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span>
        <span class="k">elif</span> <span class="n">embeddings_func</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
            <span class="c1"># Note: Here we don&#39;t simply apply PCA, but normalize it first to make</span>
            <span class="c1"># it appropriate for cosine similarity</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">FunctionTransformer</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>

            <span class="n">l2_normalization</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">X</span><span class="p">:</span> <span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;l2&quot;</span><span class="p">),</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">Pipeline</span><span class="p">(</span>
                <span class="p">[(</span><span class="s2">&quot;normalize&quot;</span><span class="p">,</span> <span class="n">l2_normalization</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">))]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span>
        <span class="k">elif</span> <span class="n">embeddings_func</span> <span class="o">==</span> <span class="s2">&quot;ncvis&quot;</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">ncvis</span>  <span class="c1"># To install, see https://github.com/cosmograph-org/priv_cosmo/discussions/1#discussioncomment-9579428</span>

            <span class="k">return</span> <span class="n">ncvis</span><span class="o">.</span><span class="n">NCVis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not a valid planar embedding kind: </span><span class="si">{</span><span class="n">embeddings_func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not a valid planar embedding type: </span><span class="si">{</span><span class="n">embeddings_func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">PlanarEmbeddingSpec</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlanarEmbeddingKind</span><span class="p">,</span> <span class="n">PlanarEmbeddingFunc</span><span class="p">]</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_pipeline</span>

<span class="n">DFLT_PREPROCESS</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">StandardScaler</span><span class="p">(),</span> <span class="n">PCA</span><span class="p">())</span><span class="o">.</span><span class="n">fit_transform</span>


<div class="viewcode-block" id="planar_embeddings">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.planar_embeddings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">planar_embeddings</span><span class="p">(</span>
    <span class="n">kd_embeddings</span><span class="p">:</span> <span class="n">EmbeddingMapping</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">embeddings_func</span><span class="p">:</span> <span class="n">PlanarEmbeddingSpec</span> <span class="o">=</span> <span class="n">DFLT_PLANAR_EMBEDDING_KIND</span><span class="p">,</span>
    <span class="n">preprocess</span><span class="o">=</span><span class="n">DFLT_PREPROCESS</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlanarVectorMapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes a mapping of k-dimensional (kd) embeddings and returns a dict of the 2d</span>
<span class="sd">    umap embeddings</span>

<span class="sd">    :param kd_embeddings: a dict of kd embeddings</span>
<span class="sd">    :param embeddings_func: the function to compute the embeddings</span>
<span class="sd">    :param preprocessors: a list of preprocessors to apply to the embeddings</span>
<span class="sd">    :return: a dict of the 2d umap embeddings</span>


<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; # Make a random array of 7 vectors of dimension 3</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; kd_embeddings = {i: np.random.rand(3) for i in range(7)}</span>
<span class="sd">    &gt;&gt;&gt; xy_pairs = planar_embeddings(kd_embeddings)</span>
<span class="sd">    &gt;&gt;&gt; xy_pairs  # doctest: +SKIP</span>
<span class="sd">    {0: (0.1, 0.2), 1: (0.3, 0.4), 2: (0.5, 0.6), 3: (0.7, 0.8), 4: (0.9, 0.1), 5: (0.2, 0.3),</span>
<span class="sd">    &gt;&gt;&gt; x, y = planar_embeddings.transpose_iterable(xy_pairs.values())</span>
<span class="sd">    &gt;&gt;&gt; x  # doctest: +SKIP</span>
<span class="sd">    (0.1, 0.3, 0.5, 0.7, 0.9, 0.2)</span>
<span class="sd">    &gt;&gt;&gt; y  # doctest: +SKIP</span>
<span class="sd">    (0.2, 0.4, 0.6, 0.8, 0.1, 0.3)</span>

<span class="sd">    Tip: Should you normalize your features (use preprocessors, the default here)?</span>
<span class="sd">        See https://umap-learn.readthedocs.io/en/latest/faq.html?utm_source=chatgpt.com#should-i-normalise-my-features</span>

<span class="sd">    Tip: If you need to get big vectors of the x and y coordinates, you can do this:</span>

<span class="sd">    ```</span>
<span class="sd">    x_values, y_values = zip(*planar_embeddings(kd_embeddings).values())</span>
<span class="sd">    ```</span>

<span class="sd">    Or even, in case you have a pandas dataframe or dict d:</span>

<span class="sd">    ```</span>
<span class="sd">    d[&#39;x&#39;], d[&#39;y&#39;] = zip(*planar_embeddings(d).values())</span>
<span class="sd">    ```</span>

<span class="sd">    Tip: Use planar_embeddings.transpose_iterable to do this in a readabble way:</span>

<span class="sd">    ```</span>
<span class="sd">    x_values, y_values = planar_embeddings.transpose_iterable(planar_embeddings(kd_embeddings).values())</span>
<span class="sd">    ```</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get a function to compute the embeddings</span>
    <span class="n">embeddings_func</span> <span class="o">=</span> <span class="n">planar_embeddings_func</span><span class="p">(</span><span class="n">embeddings_func</span><span class="p">)</span>

    <span class="c1"># make sure the input embeddings have a mapping interface</span>
    <span class="n">kd_embeddings</span> <span class="o">=</span> <span class="n">ensure_embedding_dict</span><span class="p">(</span><span class="n">kd_embeddings</span><span class="p">)</span>

    <span class="n">get_vector</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kd_embeddings</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">preprocess</span><span class="p">:</span>
        <span class="n">embedding_vectors</span> <span class="o">=</span> <span class="n">embeddings_func</span><span class="p">(</span><span class="n">preprocess</span><span class="p">(</span><span class="n">get_vector</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">embedding_vectors</span> <span class="o">=</span> <span class="n">embeddings_func</span><span class="p">(</span><span class="n">get_vector</span><span class="p">())</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kd_embeddings</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">embedding_vectors</span><span class="p">)}</span></div>



<span class="n">planar_embeddings</span><span class="o">.</span><span class="n">transpose_iterable</span> <span class="o">=</span> <span class="n">transpose_iterable</span>  <span class="c1"># to have it handy</span>


<span class="n">umap_2d_embeddings</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">planar_embeddings</span><span class="p">,</span> <span class="n">embeddings_func</span><span class="o">=</span><span class="s2">&quot;umap&quot;</span><span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>


<div class="viewcode-block" id="planar_embeddings_dict_to_df">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.planar_embeddings_dict_to_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">planar_embeddings_dict_to_df</span><span class="p">(</span>
    <span class="n">planar_embeddings_kv</span><span class="p">:</span> <span class="n">PlanarVectorMapping</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">x_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span>
    <span class="n">y_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
    <span class="n">index_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;id_&quot;</span><span class="p">,</span>
    <span class="n">key_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function that takes a dict of planar embeddings and returns a pandas DataFrame</span>
<span class="sd">    of the 2d embeddings</span>

<span class="sd">    If key_col is not None, the keys are added as a column in the dataframe.</span>

<span class="sd">    :param planar_embeddings_kv: a dict of planar embeddings</span>
<span class="sd">    :param x_col: the name of the x column</span>
<span class="sd">    :param y_col: the name of the y column</span>
<span class="sd">    :param index_name: the name of the index</span>
<span class="sd">    :param key_col: if you want to add a column with the index values copied into them</span>
<span class="sd">    :return: a pandas DataFrame of the 2d embeddings</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; planar_embeddings_kv = {1: (0.1, 0.2), 2: (0.3, 0.4)}</span>
<span class="sd">    &gt;&gt;&gt; planar_embeddings_dict_to_df(planar_embeddings_kv)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">           x    y</span>
<span class="sd">    id_</span>
<span class="sd">    1    0.1  0.2</span>
<span class="sd">    2    0.3  0.4</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">index</span><span class="o">=</span><span class="n">planar_embeddings_kv</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
        <span class="n">data</span><span class="o">=</span><span class="n">planar_embeddings_kv</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">key_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key_col</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">key_col</span> <span class="o">=</span> <span class="n">index_name</span>  <span class="c1"># default key column name is the index name</span>
        <span class="n">df</span><span class="p">[</span><span class="n">key_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>

    <span class="k">return</span> <span class="n">df</span></div>



<span class="n">two_d_embedding_dict_to_df</span> <span class="o">=</span> <span class="n">planar_embeddings_dict_to_df</span>  <span class="c1"># back-compatibility alias</span>


<div class="viewcode-block" id="umap_2d_embeddings_df">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.umap_2d_embeddings_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">umap_2d_embeddings_df</span><span class="p">(</span>
    <span class="n">kd_embeddings</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">x_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span>
    <span class="n">y_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
    <span class="n">index_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;id_&quot;</span><span class="p">,</span>
    <span class="n">key_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function that takes a mapping of kd embeddings and returns a pandas DataFrame</span>
<span class="sd">    of the 2d umap embeddings&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">planar_embeddings_dict_to_df</span><span class="p">(</span>
        <span class="n">umap_2d_embeddings</span><span class="p">(</span><span class="n">kd_embeddings</span><span class="p">),</span>
        <span class="n">x_col</span><span class="o">=</span><span class="n">x_col</span><span class="p">,</span>
        <span class="n">y_col</span><span class="o">=</span><span class="n">y_col</span><span class="p">,</span>
        <span class="n">index_name</span><span class="o">=</span><span class="n">index_name</span><span class="p">,</span>
        <span class="n">key_col</span><span class="o">=</span><span class="n">key_col</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># data store utils</span>
<span class="c1">#</span>
<span class="c1"># A lot of what is defined here are functions that are used to transform data.</span>
<span class="c1"># More precisely, encode and decode data depending on it&#39;s format, file extension, etc.</span>
<span class="c1"># TODO: Merge with codec-matching (&quot;routing&quot;?) functionalities of dol</span>

<span class="c1"># TODO: Moved a bunch of stuff to tabled.wrappers. Importing here for back-compatibility</span>
<span class="c1">#    but should be removed in the future.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tabled.wrappers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_extension</span><span class="p">,</span>  <span class="c1"># Return the extension of a file path</span>
    <span class="n">if_extension_not_present_add_it</span><span class="p">,</span>  <span class="c1"># Add an extension to a file path if it&#39;s not already there</span>
    <span class="n">if_extension_present_remove_it</span><span class="p">,</span>  <span class="c1"># Remove an extension from a file path if it&#39;s there</span>
    <span class="n">save_df_to_zipped_tsv</span><span class="p">,</span>  <span class="c1"># Save a dataframe to a zipped TSV file</span>
    <span class="n">extension_to_encoder</span><span class="p">,</span>  <span class="c1"># Dictionary mapping extensions to encoder functions</span>
    <span class="n">extension_to_decoder</span><span class="p">,</span>  <span class="c1"># Dictionary mapping extensions to decoder functions</span>
    <span class="n">get_codec_mappings</span><span class="p">,</span>  <span class="c1"># Get the current encoder and decoder mappings</span>
    <span class="n">print_current_mappings</span><span class="p">,</span>  <span class="c1"># Print the current encoder and decoder mappings</span>
    <span class="n">add_extension_codec</span><span class="p">,</span>  <span class="c1"># Add an extension-based encoder and decoder to the extension-code mapping</span>
    <span class="n">extension_based_wrap</span><span class="p">,</span>  <span class="c1"># Add extension-based encoding and decoding to a store,</span>
    <span class="n">auto_decode_bytes</span><span class="p">,</span>  <span class="c1"># Decode bytes to a string if it&#39;s a bytes object</span>
<span class="p">)</span>

<span class="c1"># TODO: Use dol tools for this.</span>
<span class="c1"># Make a codecs for imbed</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">written_bytes</span>


<span class="n">extension_to_encoder</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;txt&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">),</span>
    <span class="s2">&quot;json&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
    <span class="s2">&quot;pkl&quot;</span><span class="p">:</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
    <span class="s2">&quot;parquet&quot;</span><span class="p">:</span> <span class="n">written_bytes</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">,</span> <span class="n">obj_arg_position_in_writer</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;npy&quot;</span><span class="p">:</span> <span class="n">written_bytes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">,</span> <span class="n">obj_arg_position_in_writer</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;csv&quot;</span><span class="p">:</span> <span class="n">written_bytes</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">to_csv</span><span class="p">),</span>
    <span class="s2">&quot;xlsx&quot;</span><span class="p">:</span> <span class="n">written_bytes</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">to_excel</span><span class="p">),</span>
    <span class="s2">&quot;tsv&quot;</span><span class="p">:</span> <span class="n">written_bytes</span><span class="p">(</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">to_csv</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">escapechar</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="p">),</span>
<span class="p">}</span>

<span class="n">extension_to_decoder</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;txt&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">),</span>
    <span class="s2">&quot;json&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">,</span>
    <span class="s2">&quot;pkl&quot;</span><span class="p">:</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">,</span>
    <span class="s2">&quot;parquet&quot;</span><span class="p">:</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">),</span>
    <span class="s2">&quot;npy&quot;</span><span class="p">:</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
    <span class="s2">&quot;csv&quot;</span><span class="p">:</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">auto_decode_bytes</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">),</span>
    <span class="s2">&quot;xlsx&quot;</span><span class="p">:</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">),</span>
    <span class="s2">&quot;tsv&quot;</span><span class="p">:</span> <span class="n">Pipe</span><span class="p">(</span>
        <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">escapechar</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="p">),</span>
<span class="p">}</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tabled.wrappers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">extension_based_encoding</span> <span class="k">as</span> <span class="n">_extension_based_encoding</span><span class="p">,</span>  <span class="c1"># Encode a value based on the extension of the key</span>
    <span class="n">extension_based_decoding</span> <span class="k">as</span> <span class="n">_extension_based_decoding</span><span class="p">,</span>  <span class="c1"># Decode a value based on the extension of the key</span>
<span class="p">)</span>

<span class="n">extension_based_encoding</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">_extension_based_encoding</span><span class="p">,</span> <span class="n">extension_to_encoder</span><span class="o">=</span><span class="n">extension_to_encoder</span>
<span class="p">)</span>
<span class="n">extension_based_decoding</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">_extension_based_decoding</span><span class="p">,</span> <span class="n">extension_to_decoder</span><span class="o">=</span><span class="n">extension_to_decoder</span>
<span class="p">)</span>

<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># Matching utils</span>
<span class="c1">#</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">Role</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Role&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Field</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Field&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Regex</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Regex&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>


<span class="c1"># TODO: Move, or copy, to doodad</span>
<div class="viewcode-block" id="match_aliases">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.match_aliases">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_aliases</span><span class="p">(</span>
    <span class="n">fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Field</span><span class="p">],</span>
    <span class="n">aliases</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="n">Role</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Field</span><span class="p">],</span> <span class="n">Regex</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Field</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Field</span><span class="p">]]]</span>
    <span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Role</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Field</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches the keys of aliases to the given fields,</span>
<span class="sd">    using the values of aliases as the matching logic (could be a list of possible</span>
<span class="sd">    fields, a regular expression, or a custom matching function.).</span>

<span class="sd">    A dictionary</span>

<span class="sd">    Args:</span>
<span class="sd">        fields (List[Field]): A list of fields</span>
<span class="sd">        aliases (Dict[Role, Union[List[Field], Regex, Callable[[List[Field]], Optional[Field]]]]): A dictionary where:</span>
<span class="sd">            - Keys are roles (e.g., &#39;ID&#39;, &#39;Name&#39;) we&#39;re looking for</span>
<span class="sd">            - Values are either:</span>
<span class="sd">                - A list of field &quot;aliases&quot; (e.g., [&#39;id&#39;, &#39;user_id&#39;]).</span>
<span class="sd">                - A string representing a regular expression (e.g., r&#39;user.*id&#39;).</span>
<span class="sd">                - A function that takes a list of fields and returns a matched field or None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[Role, Optional[Field]]: A dictionary mapping each role to the first matching</span>
<span class="sd">                                     field found in `fields`, or `None` if no match is</span>
<span class="sd">                                     found. Once a column is matched, it is removed</span>
<span class="sd">                                     from further matching, so it can&#39;t be matched again.</span>


<span class="sd">    Example 1: List-based aliases, regex, and custom function matching</span>

<span class="sd">    &gt;&gt;&gt; fields = [&#39;user_id&#39;, &#39;full_name&#39;, &#39;created_at&#39;, &#39;email_address&#39;]</span>
<span class="sd">    &gt;&gt;&gt; aliases = {</span>
<span class="sd">    ...     &#39;ID&#39;: [&#39;id&#39;, &#39;user_id&#39;],  # List of possible aliases for &#39;ID&#39;</span>
<span class="sd">    ...     &#39;Name&#39;: r&#39;.*name&#39;,  # Regular expression for &#39;Name&#39;</span>
<span class="sd">    ...     &#39;Date&#39;: lambda cols: next((col for col in cols if &quot;date&quot; in col.lower() or &quot;created&quot; in col.lower()), None)  # Custom matching function</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; match_aliases(fields, aliases)</span>
<span class="sd">    {&#39;ID&#39;: &#39;user_id&#39;, &#39;Name&#39;: &#39;full_name&#39;, &#39;Date&#39;: &#39;created_at&#39;}</span>

<span class="sd">    # Example 2: Handles conflict resolution by removing matched columns</span>

<span class="sd">    &gt;&gt;&gt; fields = [&#39;id&#39;, &#39;full_name&#39;, &#39;id_created&#39;, &#39;email_address&#39;]</span>
<span class="sd">    &gt;&gt;&gt; aliases = {</span>
<span class="sd">    ...     &#39;Primary ID&#39;: [&#39;id&#39;],  # List-based alias that should match &#39;id&#39; first</span>
<span class="sd">    ...     &#39;Secondary ID&#39;: r&#39;id.*&#39;,  # Regex to match anything starting with &#39;id&#39;</span>
<span class="sd">    ...     &#39;Email&#39;: lambda cols: next((col for col in cols if &#39;email&#39; in col.lower()), None)  # Custom function for email</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; match_aliases(fields, aliases)</span>
<span class="sd">    {&#39;Primary ID&#39;: &#39;id&#39;, &#39;Secondary ID&#39;: &#39;id_created&#39;, &#39;Email&#39;: &#39;email_address&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">normalize_alias</span><span class="p">(</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the alias to a matching function.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Convert the list into a regular expression</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">columns</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span>
                <span class="p">(</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Treat the string as a regular expression</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">columns</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span>
                <span class="p">(</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># It&#39;s already a matching function</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alias must be a list, string, or callable.&quot;</span><span class="p">)</span>

    <span class="c1"># Normalize all alias entries into functions</span>
    <span class="n">alias_functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">role</span><span class="p">:</span> <span class="n">normalize_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">aliases</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">role_to_column</span> <span class="o">=</span> <span class="p">{</span><span class="n">role</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">role</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">}</span>  <span class="c1"># Initialize result dictionary</span>
    <span class="n">remaining_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>  <span class="c1"># Set of columns that haven&#39;t been matched yet</span>

    <span class="c1"># Process each role and its corresponding matching function</span>
    <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">match_func</span> <span class="ow">in</span> <span class="n">alias_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">matched_column</span> <span class="o">=</span> <span class="n">match_func</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">remaining_columns</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># Apply the matching function to the remaining columns</span>
        <span class="k">if</span> <span class="n">matched_column</span><span class="p">:</span>
            <span class="n">role_to_column</span><span class="p">[</span><span class="n">role</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched_column</span>
            <span class="n">remaining_columns</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="n">matched_column</span>
            <span class="p">)</span>  <span class="c1"># Remove the matched column from further consideration</span>

    <span class="k">return</span> <span class="n">role_to_column</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># TODO: Deprecated: Replaced by dol.cache_this</span>
<div class="viewcode-block" id="load_if_saved">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.load_if_saved">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_if_saved</span><span class="p">(</span>
    <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">store_attr</span><span class="o">=</span><span class="s2">&quot;saves&quot;</span><span class="p">,</span>
    <span class="n">save_on_compute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">print_when_loading_from_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to load the value from the store if it is saved, otherwise compute it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="c1"># Assume load_if_saved is being called on the method and that the key should</span>
        <span class="c1"># be the method name.</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">load_if_saved</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">store_attr</span><span class="p">,</span> <span class="n">save_on_compute</span><span class="o">=</span><span class="n">save_on_compute</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_if_saved</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">store</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store_attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_when_loading_from_file</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> from file&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save_on_compute</span><span class="p">:</span>
                    <span class="n">store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="k">return</span> <span class="n">obj</span>

        <span class="k">return</span> <span class="n">_method</span>

    <span class="k">return</span> <span class="n">_load_if_saved</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># data manipulation</span>

<span class="n">MatrixData</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>


<div class="viewcode-block" id="merge_data">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.merge_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_data</span><span class="p">(</span>
    <span class="n">data_1</span><span class="p">:</span> <span class="n">MatrixData</span><span class="p">,</span>
    <span class="n">data_2</span><span class="p">:</span> <span class="n">MatrixData</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">merge_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data_1_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_2_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_index_cursor_start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merges two sources of data, returning a dataframe.</span>

<span class="sd">    The sources of data could be numpy arrays or pandas DataFrames.</span>

<span class="sd">    If they&#39;re both dataframes, the merge_on specification is needed.</span>
<span class="sd">    If at least one of them is a numpy array, data_1 and data_2 must have the same</span>
<span class="sd">    number of rows and merge_on is ignored, since the merge will simply be the</span>
<span class="sd">    concatination of the two datas over the rows (that is, the result will have</span>
<span class="sd">    that common number of rows and the number of columns will be added).</span>

<span class="sd">    The optional data_1_cols and data_2_cols are used to transform numpy matrices into</span>
<span class="sd">    dataframes with the given column names.</span>

<span class="sd">    :param data_1: The first source of data.</span>
<span class="sd">    :param data_2: The second source of data.</span>
<span class="sd">    :param merge_on: The column to merge on, if both data_1 and data_2 are dataframes.</span>
<span class="sd">    :param data_1_cols: The column names for the first source of data, if it is a numpy array.</span>
<span class="sd">    :param data_2_cols: The column names for the second source of data, if it is a numpy array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">column_index_cursor</span> <span class="o">=</span> <span class="n">column_index_cursor_start</span>

    <span class="c1"># if only one of the data sources is a numpy array, we need to get the</span>
    <span class="c1"># row indices of the dataframe data to use when making a dataframe for the array</span>
    <span class="n">data_1_row_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">)))</span>
    <span class="n">data_2_row_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">data_1_row_indices</span> <span class="o">=</span> <span class="n">data_1</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_2</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">data_2_row_indices</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_1_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_1_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">column_index_cursor</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1_cols</span><span class="p">)</span>
        <span class="n">data_1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data_1_cols</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data_2_row_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Data 1 and Data 2 must have the same length. Instead, we got: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">data_2_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_2_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">column_index_cursor</span><span class="p">,</span> <span class="n">column_index_cursor</span> <span class="o">+</span> <span class="n">data_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="n">data_2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_2</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data_2_cols</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data_1_row_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">merge_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">merge_on</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">counts</span><span class="p">(</span><span class="n">sr</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="c1"># return pd.Series(dict(Counter(sr).most_common()))</span>
    <span class="k">return</span> <span class="n">sr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>


<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># more misc</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol</span><span class="w"> </span><span class="kn">import</span> <span class="n">Files</span><span class="p">,</span> <span class="n">add_extension</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">config2py</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lkj</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_progress</span>


<span class="n">CacheSpec</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_string_with_path_seps</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span> <span class="ow">in</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">ensure_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">:</span> <span class="n">CacheSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MutableMapping</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rootdir</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ensure_dir_exists</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Files</span><span class="p">(</span><span class="n">rootdir</span><span class="p">)</span>
        <span class="c1"># if os.path.isdir(cache):</span>
        <span class="c1">#     rootdir = process_path(cache, ensure_dir_exists=1)</span>
        <span class="c1">#     return Files(rootdir)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     raise ValueError(f&quot;cache directory {cache} does not exist&quot;)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cache</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cache must be a str or MutableMapping, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ensure_fullpath">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.ensure_fullpath">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_fullpath</span><span class="p">(</span><span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">conditional_rootdir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures a full path, prepending a rootdir if input is a (slash-less) file name.</span>

<span class="sd">    If you pass in a file name, it will be considered relative to the current directory.</span>
<span class="sd">    In all other situations, the conditional_rootdir is ignored, and the filepath is</span>
<span class="sd">    taken at face value.</span>
<span class="sd">    All outputs will be processed to ensure a full path is returned.</span>

<span class="sd">    &gt;&gt;&gt; ensure_fullpath(&#39;apple/sauce&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;.../apple/sauce&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     ensure_fullpath(&#39;apple/sauce&#39;)</span>
<span class="sd">    ...     == ensure_fullpath(&#39;./apple/sauce&#39;)</span>
<span class="sd">    ...     == ensure_fullpath(&#39;apple/sauce&#39;, &#39;&#39;)</span>
<span class="sd">    ... )</span>

<span class="sd">    The only time you actually use the rootdir is when you pass in a file name</span>
<span class="sd">    that doesn&#39;t have slashes in it.</span>

<span class="sd">    &gt;&gt;&gt; ensure_fullpath(&#39;apple&#39;, &#39;/root/dir&#39;)</span>
<span class="sd">    &#39;/root/dir/apple&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string_with_path_seps</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>  <span class="c1"># then consider it a file name</span>
        <span class="c1"># ... and instead of taking the file name to be relative to the current</span>
        <span class="c1"># directory, we&#39;ll take it to be relative to the conditional_rootdir.</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">process_path</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="n">conditional_rootdir</span><span class="p">)</span>
    <span class="c1"># elif conditional_rootdir:</span>
    <span class="c1">#     warnings.warn(</span>
    <span class="c1">#         f&quot;ignoring rootdir {conditional_rootdir} for full path {filepath}&quot;</span>
    <span class="c1">#     )</span>

    <span class="k">return</span> <span class="n">process_path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span></div>



<span class="n">add_extension</span>  <span class="c1"># just to avoid unused import warning</span>


<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># graph utils</span>

<span class="n">Node</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
<span class="n">Nodes</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span>


<div class="viewcode-block" id="fuzzy_induced_graph">
<a class="viewcode-back" href="../../module_docs/imbed/util.html#imbed.util.fuzzy_induced_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fuzzy_induced_graph</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">inducing_node_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">min_proportion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Keep only those (node, neighbors) pairs where both node and a minimum proportion of</span>
<span class="sd">    neighbors are in inducing_node_set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">inducing_node_set</span><span class="p">:</span>
            <span class="n">neighbors_in_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">inducing_node_set</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors_in_set</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_proportion</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors_in_set</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>